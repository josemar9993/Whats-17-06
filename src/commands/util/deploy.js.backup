const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');

module.exports = {
  name: 'deploy',
  description: 'Executa deploy automÃ¡tico no servidor (somente administradores)',
  aliases: ['update', 'atualizar'],
  cooldown: 30, // 30 segundos de cooldown para evitar spam
  adminOnly: true, // Apenas administradores podem usar
  async execute(message, args, client) {
    const logger = require('../../logger');
    const config = require('../../config');
    
    // Log para debug
    logger.info(`Comando deploy recebido de: ${message.from}`);
    logger.info(`Argumentos: ${args}`);
    logger.info(`Admin IDs configurados: ${config.adminIds}`);
    
    // Verificar se Ã© administrador
    const senderId = message.from;
    if (!config.adminIds.includes(senderId)) {
      await message.reply(`âŒ **Acesso negado!**\n\nApenas administradores podem executar deploy.\n\nğŸ” **Debug:**\nâ€¢ Seu ID: \`${senderId}\`\nâ€¢ IDs autorizados: \`${config.adminIds.join(', ')}\`\n\nğŸ’¡ Configure seu nÃºmero em ADMIN_WHATSAPP_IDS no arquivo .env`);
      return;
    }

    // Verificar argumentos
    const action = args[0] || 'help';
    
    try {
      switch (action.toLowerCase()) {
        case 'servidor':
        case 'server':
          await deployServidor(message, client);
          break;
          
        case 'local':
          await deployLocal(message, client);
          break;
          
        case 'docker':
          await deployDocker(message, client);
          break;
          
        case 'status':
          await deployStatus(message, client);
          break;
          
        case 'logs':
          await deployLogs(message, client);
          break;
          
        case 'restart':
          await deployRestart(message, client);
          break;
          
        case 'test':
        case 'teste':
          await deployTest(message, client);
          break;
          
        default:
          await message.reply(`ğŸš€ **COMANDO DEPLOY**

**Uso:** \`!deploy [aÃ§Ã£o]\`

**ğŸ“‹ AÃ§Ãµes disponÃ­veis:**
â€¢ \`!deploy servidor\` - Deploy no servidor remoto (161.35.176.216)
â€¢ \`!deploy status\` - Status do sistema
â€¢ \`!deploy logs\` - Ãšltimos logs
â€¢ \`!deploy restart\` - Reiniciar PM2
â€¢ \`!deploy test\` - Teste de conectividade
â€¢ \`!deploy local\` - Restart local
â€¢ \`!deploy docker\` - Deploy com Docker

**ğŸ¯ Exemplo:**
\`!deploy servidor\` - Para atualizar o servidor

**ğŸ” Apenas administradores podem usar este comando.**`);
      }
    } catch (error) {
      logger.error('Erro no comando deploy:', error);
      await message.reply(`âŒ **Erro no deploy**\n\n\`\`\`${error.message}\`\`\`\n\nğŸ’¡ Verifique os logs para mais detalhes.`);
    }
  }
};

// FunÃ§Ã£o para teste de conectividade
async function deployTest(message, client) {
  const logger = require('../../logger');
  
  await message.reply('ğŸ” **TESTE DE CONECTIVIDADE**\n\nâ³ Testando conexÃ£o com servidor...');
  
  return new Promise((resolve, reject) => {
    // Teste bÃ¡sico de conectividade
    exec('ping -c 3 161.35.176.216', { timeout: 15000 }, async (error, stdout, stderr) => {
      let testResult = 'ğŸ“Š **RESULTADO DOS TESTES**\n\n';
      
      if (error) {
        testResult += 'âŒ **Ping:** Falhou\n';
        testResult += `\`\`\`${error.message}\`\`\`\n\n`;
      } else {
        testResult += 'âœ… **Ping:** Sucesso\n';
      }
      
      // Teste SSH
      exec('timeout 10s ssh -o ConnectTimeout=5 -o BatchMode=yes root@161.35.176.216 "echo SSH_OK"', 
           { timeout: 15000 }, async (sshError, sshOut) => {
        if (sshError) {
          testResult += 'âŒ **SSH:** Falhou\n';
          testResult += 'ğŸ’¡ **SoluÃ§Ã£o:** Configure SSH com `ssh-keygen` e `ssh-copy-id`\n\n';
        } else {
          testResult += 'âœ… **SSH:** Funcionando\n\n';
        }
        
        // Teste Health endpoint
        exec('curl -m 5 -s http://161.35.176.216:8080/health', 
             { timeout: 10000 }, async (healthError, healthOut) => {
          if (healthError) {
            testResult += 'âŒ **Health Check:** Falhou\n';
            testResult += 'ğŸ’¡ **SoluÃ§Ã£o:** Verifique se o bot estÃ¡ rodando no servidor\n\n';
          } else {
            testResult += 'âœ… **Health Check:** Funcionando\n';
            testResult += `ğŸ“Š **Resposta:** \`${healthOut}\`\n\n`;
          }
          
          // Verificar script de deploy
          const deployScript = path.join(__dirname, '../../..', 'deploy-whatsapp.sh');
          if (fs.existsSync(deployScript)) {
            testResult += 'âœ… **Script Deploy:** Encontrado\n';
          } else {
            testResult += 'âŒ **Script Deploy:** NÃ£o encontrado\n';
          }
          
          testResult += '\nğŸ¯ **Status:** ';
          if (!error && !sshError) {
            testResult += 'Pronto para deploy!\n\nğŸ’¡ **Use:** `!deploy servidor`';
          } else {
            testResult += 'Requer configuraÃ§Ã£o\n\nğŸ’¡ **Configure SSH primeiro**';
          }
          
          await message.reply(testResult);
          resolve();
        });
      });
    });
  });
}

// FunÃ§Ã£o para deploy no servidor (versÃ£o melhorada)
async function deployServidor(message, client) {
  const logger = require('../../logger');
  
  // Primeira mensagem de confirmaÃ§Ã£o
  await message.reply('ğŸš€ **INICIANDO DEPLOY NO SERVIDOR**\n\nğŸ“ **Servidor:** 161.35.176.216\nâ³ **Status:** Conectando...\n\nğŸ”„ Este processo pode levar atÃ© 3 minutos.');
  
  return new Promise((resolve, reject) => {
    const deployScript = path.join(__dirname, '../../..', 'deploy-whatsapp.sh');
    
    // Verificar se o script existe
    if (!fs.existsSync(deployScript)) {
      message.reply('âŒ **Script de deploy nÃ£o encontrado!**\n\nğŸ’¡ **SoluÃ§Ã£o:**\n1. Verifique se o arquivo `deploy-whatsapp.sh` existe\n2. Execute `chmod +x deploy-whatsapp.sh`');
      return reject(new Error('Script nÃ£o encontrado'));
    }
    
    // Log detalhado
    logger.info('Iniciando deploy no servidor via WhatsApp');
    logger.info(`Script path: ${deployScript}`);
    
    // Executar deploy com timeout aumentado
    exec(`bash ${deployScript}`, { 
      timeout: 180000, // 3 minutos
      maxBuffer: 1024 * 1024 // 1MB buffer
    }, async (error, stdout, stderr) => {
      
      if (error) {
        logger.error('Erro no deploy servidor:', error);
        
        let errorMsg = 'âŒ **DEPLOY FALHOU**\n\n';
        
        if (error.code === 'ETIMEDOUT') {
          errorMsg += 'â° **Erro:** Timeout (3 minutos)\n';
          errorMsg += 'ğŸ’¡ **Causa:** Servidor demorou para responder\n\n';
        } else if (error.message.includes('Connection refused')) {
          errorMsg += 'ï¿½ **Erro:** ConexÃ£o recusada\n';
          errorMsg += 'ğŸ’¡ **Causa:** SSH nÃ£o configurado ou servidor offline\n\n';
        } else {
          errorMsg += `ğŸ“‹ **Erro:**\n\`\`\`${error.message.substring(0, 200)}\`\`\`\n\n`;
        }
        
        errorMsg += 'ğŸ”§ **SoluÃ§Ãµes:**\n';
        errorMsg += '1. Execute `!deploy test` para diagnÃ³stico\n';
        errorMsg += '2. Configure SSH: `ssh-copy-id root@161.35.176.216`\n';
        errorMsg += '3. Verifique se servidor estÃ¡ online\n';
        
        await message.reply(errorMsg);
        return reject(error);
      }
      
      // Log da saÃ­da completa
      logger.info('Deploy output:', stdout);
      if (stderr) logger.warn('Deploy stderr:', stderr);
      
      // Processar saÃ­da
      const output = stdout || '';
      const success = output.includes('DEPLOY CONCLUÃDO - SISTEMA ATUALIZADO') || 
                     output.includes('ğŸ‰ DEPLOY FINALIZADO COM SUCESSO');
      const healthOk = output.includes('Health check passou') || 
                      output.includes('Health check OK');
      const gitOk = output.includes('Git pull') || output.includes('âœ…');
      const pm2Ok = output.includes('Restart PM2') || output.includes('pm2 restart');
      
      if (success) {
        const statusIcon = healthOk ? 'ğŸŸ¢' : 'ğŸŸ¡';
        
        let successMsg = 'âœ… **DEPLOY CONCLUÃDO COM SUCESSO!**\n\n';
        successMsg += `${statusIcon} **Status:** ${healthOk ? 'SaudÃ¡vel' : 'Funcionando'}\n\n`;
        successMsg += 'ğŸ“Š **Resumo da atualizaÃ§Ã£o:**\n';
        successMsg += `${gitOk ? 'âœ…' : 'âš ï¸'} CÃ³digo atualizado do GitHub\n`;
        successMsg += `${pm2Ok ? 'âœ…' : 'âš ï¸'} Bot reiniciado via PM2\n`;
        successMsg += `${healthOk ? 'âœ…' : 'âš ï¸'} Health check executado\n`;
        successMsg += 'âœ… Sistema operacional\n\n';
        successMsg += 'ğŸ‰ **Servidor 161.35.176.216 atualizado!**\n\n';
        successMsg += 'ğŸ“± **PrÃ³ximos passos:**\n';
        successMsg += 'â€¢ Teste os comandos do bot\n';
        successMsg += 'â€¢ Use `!deploy status` para monitorar\n';
        successMsg += 'â€¢ Use `!deploy logs` se houver problemas';
        
        await message.reply(successMsg);
      } else {
        let warningMsg = 'âš ï¸ **DEPLOY COM PROBLEMAS**\n\n';
        warningMsg += 'ğŸ“‹ **SaÃ­da do processo:**\n';
        warningMsg += `\`\`\`${output.substring(0, 800)}\`\`\`\n\n`;
        warningMsg += 'ğŸ’¡ **RecomendaÃ§Ãµes:**\n';
        warningMsg += '1. Execute `!deploy status` para verificar\n';
        warningMsg += '2. Use `!deploy logs` para mais detalhes\n';
        warningMsg += '3. Tente `!deploy restart` se necessÃ¡rio';
        
        await message.reply(warningMsg);
      }
      
      resolve();
    });
  });
}

// FunÃ§Ã£o para deploy local
async function deployLocal(message, client) {
  const logger = require('../../logger');
  
  await message.reply('ğŸ”„ **REINICIANDO SISTEMA LOCAL**\\n\\nâ³ Processando...');
  
  return new Promise((resolve, reject) => {
    exec('npm run validate', { timeout: 60000 }, async (error, stdout, stderr) => {
      if (error) {
        await message.reply(`âŒ **VALIDAÃ‡ÃƒO FALHOU**\\n\\n\`\`\`${error.message}\`\`\``);
        return reject(error);
      }
      
      // Reiniciar processo
      await message.reply('âœ… **VALIDAÃ‡ÃƒO OK**\\n\\nğŸ”„ Reiniciando sistema...');
      
      setTimeout(async () => {
        await message.reply('âœ… **SISTEMA REINICIADO**\\n\\nğŸ‰ Bot funcionando normalmente!');
        resolve();
      }, 2000);
    });
  });
}

// FunÃ§Ã£o para deploy com Docker
async function deployDocker(message, client) {
  await message.reply('ğŸ³ **DEPLOY COM DOCKER**\\n\\nâ³ Construindo imagem...');
  
  return new Promise((resolve, reject) => {
    exec('npm run docker:build-local', { timeout: 300000 }, async (error, stdout, stderr) => {
      if (error) {
        await message.reply(`âŒ **DOCKER BUILD FALHOU**\\n\\n\`\`\`${error.message}\`\`\``);
        return reject(error);
      }
      
      await message.reply('âœ… **DOCKER BUILD CONCLUÃDO**\\n\\nğŸ‰ Imagem pronta para uso!');
      resolve();
    });
  });
}

// FunÃ§Ã£o para status do sistema
async function deployStatus(message, client) {
  return new Promise((resolve, reject) => {
    exec('pm2 status', { timeout: 10000 }, async (error, stdout, stderr) => {
      let statusMsg = 'ğŸ“Š **STATUS DO SISTEMA**\\n\\n';
      
      if (error) {
        statusMsg += 'âŒ PM2 nÃ£o disponÃ­vel localmente\\n\\n';
      } else {
        statusMsg += `\`\`\`${stdout.substring(0, 500)}\`\`\`\\n\\n`;
      }
      
      // Verificar health endpoint
      exec('curl -s http://localhost:8080/health || echo "Health endpoint nÃ£o disponÃ­vel"', 
           { timeout: 5000 }, async (healthError, healthOut) => {
        statusMsg += `ğŸŒ **Health Check:**\\n\`\`\`${healthOut || 'NÃ£o disponÃ­vel'}\`\`\`\\n\\n`;
        
        // Verificar uptime
        const uptimeHours = Math.floor(process.uptime() / 3600);
        const uptimeMinutes = Math.floor((process.uptime() % 3600) / 60);
        statusMsg += `â° **Uptime:** ${uptimeHours}h ${uptimeMinutes}m`;
        
        await message.reply(statusMsg);
        resolve();
      });
    });
  });
}

// FunÃ§Ã£o para logs
async function deployLogs(message, client) {
  return new Promise((resolve, reject) => {
    exec('pm2 logs whatsapp-bot --lines 10 --nostream', { timeout: 10000 }, async (error, stdout, stderr) => {
      let logMsg = 'ğŸ“‹ **ÃšLTIMOS LOGS**\\n\\n';
      
      if (error) {
        logMsg += 'âŒ Logs PM2 nÃ£o disponÃ­veis\\n\\n';
        // Tentar logs locais
        exec('tail -10 logs/*.log', { timeout: 5000 }, async (logError, logOut) => {
          if (!logError && logOut) {
            logMsg += `\`\`\`${logOut.substring(0, 800)}\`\`\``;
          } else {
            logMsg += 'Nenhum log disponÃ­vel';
          }
          
          await message.reply(logMsg);
          resolve();
        });
      } else {
        logMsg += `\`\`\`${stdout.substring(0, 800)}\`\`\``;
        await message.reply(logMsg);
        resolve();
      }
    });
  });
}

// FunÃ§Ã£o para restart PM2
async function deployRestart(message, client) {
  await message.reply('ğŸ”„ **REINICIANDO PM2**\\n\\nâ³ Processando...');
  
  return new Promise((resolve, reject) => {
    exec('pm2 restart whatsapp-bot', { timeout: 30000 }, async (error, stdout, stderr) => {
      if (error) {
        await message.reply(`âŒ **RESTART FALHOU**\\n\\n\`\`\`${error.message}\`\`\``);
        return reject(error);
      }
      
      await message.reply('âœ… **PM2 REINICIADO**\\n\\nğŸ‰ Sistema funcionando normalmente!');
      resolve();
    });
  });
}

