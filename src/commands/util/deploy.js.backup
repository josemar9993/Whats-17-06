const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');

module.exports = {
  name: 'deploy',
  description: 'Executa deploy autom√°tico no servidor (somente administradores)',
  aliases: ['update', 'atualizar'],
  cooldown: 30, // 30 segundos de cooldown para evitar spam
  adminOnly: true, // Apenas administradores podem usar
  async execute(message, args, client) {
    const logger = require('../../logger');
    const config = require('../../config');
    
    // Log para debug
    logger.info(`Comando deploy recebido de: ${message.from}`);
    logger.info(`Argumentos: ${args}`);
    logger.info(`Admin IDs configurados: ${config.adminIds}`);
    
    // Verificar se √© administrador
    const senderId = message.from;
    if (!config.adminIds.includes(senderId)) {
      await message.reply(`‚ùå **Acesso negado!**\n\nApenas administradores podem executar deploy.\n\nüîç **Debug:**\n‚Ä¢ Seu ID: \`${senderId}\`\n‚Ä¢ IDs autorizados: \`${config.adminIds.join(', ')}\`\n\nüí° Configure seu n√∫mero em ADMIN_WHATSAPP_IDS no arquivo .env`);
      return;
    }

    // Verificar argumentos
    const action = args[0] || 'help';
    
    try {
      switch (action.toLowerCase()) {
        case 'servidor':
        case 'server':
          await deployServidor(message, client);
          break;
          
        case 'local':
          await deployLocal(message, client);
          break;
          
        case 'docker':
          await deployDocker(message, client);
          break;
          
        case 'status':
          await deployStatus(message, client);
          break;
          
        case 'logs':
          await deployLogs(message, client);
          break;
          
        case 'restart':
          await deployRestart(message, client);
          break;
          
        case 'test':
        case 'teste':
          await deployTest(message, client);
          break;
          
        default:
          await message.reply(`üöÄ **COMANDO DEPLOY**

**Uso:** \`!deploy [a√ß√£o]\`

**üìã A√ß√µes dispon√≠veis:**
‚Ä¢ \`!deploy servidor\` - Deploy no servidor remoto (161.35.176.216)
‚Ä¢ \`!deploy status\` - Status do sistema
‚Ä¢ \`!deploy logs\` - √öltimos logs
‚Ä¢ \`!deploy restart\` - Reiniciar PM2
‚Ä¢ \`!deploy test\` - Teste de conectividade
‚Ä¢ \`!deploy local\` - Restart local
‚Ä¢ \`!deploy docker\` - Deploy com Docker

**üéØ Exemplo:**
\`!deploy servidor\` - Para atualizar o servidor

**üîê Apenas administradores podem usar este comando.**`);
      }
    } catch (error) {
      logger.error('Erro no comando deploy:', error);
      await message.reply(`‚ùå **Erro no deploy**\n\n\`\`\`${error.message}\`\`\`\n\nüí° Verifique os logs para mais detalhes.`);
    }
  }
};

// Fun√ß√£o para teste de conectividade
async function deployTest(message, client) {
  const logger = require('../../logger');
  
  await message.reply('üîç **TESTE DE CONECTIVIDADE**\n\n‚è≥ Testando conex√£o com servidor...');
  
  return new Promise((resolve, reject) => {
    // Teste b√°sico de conectividade
    exec('ping -c 3 161.35.176.216', { timeout: 15000 }, async (error, stdout, stderr) => {
      let testResult = 'üìä **RESULTADO DOS TESTES**\n\n';
      
      if (error) {
        testResult += '‚ùå **Ping:** Falhou\n';
        testResult += `\`\`\`${error.message}\`\`\`\n\n`;
      } else {
        testResult += '‚úÖ **Ping:** Sucesso\n';
      }
      
      // Teste SSH
      exec('timeout 10s ssh -o ConnectTimeout=5 -o BatchMode=yes root@161.35.176.216 "echo SSH_OK"', 
           { timeout: 15000 }, async (sshError, sshOut) => {
        if (sshError) {
          testResult += '‚ùå **SSH:** Falhou\n';
          testResult += 'üí° **Solu√ß√£o:** Configure SSH com `ssh-keygen` e `ssh-copy-id`\n\n';
        } else {
          testResult += '‚úÖ **SSH:** Funcionando\n\n';
        }
        
        // Teste Health endpoint
        exec('curl -m 5 -s http://161.35.176.216:8080/health', 
             { timeout: 10000 }, async (healthError, healthOut) => {
          if (healthError) {
            testResult += '‚ùå **Health Check:** Falhou\n';
            testResult += 'üí° **Solu√ß√£o:** Verifique se o bot est√° rodando no servidor\n\n';
          } else {
            testResult += '‚úÖ **Health Check:** Funcionando\n';
            testResult += `üìä **Resposta:** \`${healthOut}\`\n\n`;
          }
          
          // Verificar script de deploy
          const deployScript = path.join(__dirname, '../../..', 'deploy-whatsapp.sh');
          if (fs.existsSync(deployScript)) {
            testResult += '‚úÖ **Script Deploy:** Encontrado\n';
          } else {
            testResult += '‚ùå **Script Deploy:** N√£o encontrado\n';
          }
          
          testResult += '\nüéØ **Status:** ';
          if (!error && !sshError) {
            testResult += 'Pronto para deploy!\n\nüí° **Use:** `!deploy servidor`';
          } else {
            testResult += 'Requer configura√ß√£o\n\nüí° **Configure SSH primeiro**';
          }
          
          await message.reply(testResult);
          resolve();
        });
      });
    });
  });
}

// Fun√ß√£o para deploy no servidor (vers√£o melhorada)
async function deployServidor(message, client) {
  const logger = require('../../logger');
  
  // Primeira mensagem de confirma√ß√£o
  await message.reply('üöÄ **INICIANDO DEPLOY NO SERVIDOR**\n\nüìç **Servidor:** 161.35.176.216\n‚è≥ **Status:** Conectando...\n\nüîÑ Este processo pode levar at√© 3 minutos.');
  
  return new Promise((resolve, reject) => {
    const deployScript = path.join(__dirname, '../../..', 'deploy-whatsapp.sh');
    
    // Verificar se o script existe
    if (!fs.existsSync(deployScript)) {
      message.reply('‚ùå **Script de deploy n√£o encontrado!**\n\nüí° **Solu√ß√£o:**\n1. Verifique se o arquivo `deploy-whatsapp.sh` existe\n2. Execute `chmod +x deploy-whatsapp.sh`');
      return reject(new Error('Script n√£o encontrado'));
    }
    
    // Log detalhado
    logger.info('Iniciando deploy no servidor via WhatsApp');
    logger.info(`Script path: ${deployScript}`);
    
    // Executar deploy com timeout aumentado
    exec(`bash ${deployScript}`, { 
      timeout: 180000, // 3 minutos
      maxBuffer: 1024 * 1024 // 1MB buffer
    }, async (error, stdout, stderr) => {
      
      if (error) {
        logger.error('Erro no deploy servidor:', error);
        
        let errorMsg = '‚ùå **DEPLOY FALHOU**\n\n';
        
        if (error.code === 'ETIMEDOUT') {
          errorMsg += '‚è∞ **Erro:** Timeout (3 minutos)\n';
          errorMsg += 'üí° **Causa:** Servidor demorou para responder\n\n';
        } else if (error.message.includes('Connection refused')) {
          errorMsg += 'ÔøΩ **Erro:** Conex√£o recusada\n';
          errorMsg += 'üí° **Causa:** SSH n√£o configurado ou servidor offline\n\n';
        } else {
          errorMsg += `üìã **Erro:**\n\`\`\`${error.message.substring(0, 200)}\`\`\`\n\n`;
        }
        
        errorMsg += 'üîß **Solu√ß√µes:**\n';
        errorMsg += '1. Execute `!deploy test` para diagn√≥stico\n';
        errorMsg += '2. Configure SSH: `ssh-copy-id root@161.35.176.216`\n';
        errorMsg += '3. Verifique se servidor est√° online\n';
        
        await message.reply(errorMsg);
        return reject(error);
      }
      
      // Log da sa√≠da completa
      logger.info('Deploy output:', stdout);
      if (stderr) logger.warn('Deploy stderr:', stderr);
      
      // Processar sa√≠da
      const output = stdout || '';
      const success = output.includes('DEPLOY CONCLU√çDO - SISTEMA ATUALIZADO') || 
                     output.includes('üéâ DEPLOY FINALIZADO COM SUCESSO');
      const healthOk = output.includes('Health check passou') || 
                      output.includes('Health check OK');
      const gitOk = output.includes('Git pull') || output.includes('‚úÖ');
      const pm2Ok = output.includes('Restart PM2') || output.includes('pm2 restart');
      
      if (success) {
        const statusIcon = healthOk ? 'üü¢' : 'üü°';
        
        let successMsg = '‚úÖ **DEPLOY CONCLU√çDO COM SUCESSO!**\n\n';
        successMsg += `${statusIcon} **Status:** ${healthOk ? 'Saud√°vel' : 'Funcionando'}\n\n`;
        successMsg += 'üìä **Resumo da atualiza√ß√£o:**\n';
        successMsg += `${gitOk ? '‚úÖ' : '‚ö†Ô∏è'} C√≥digo atualizado do GitHub\n`;
        successMsg += `${pm2Ok ? '‚úÖ' : '‚ö†Ô∏è'} Bot reiniciado via PM2\n`;
        successMsg += `${healthOk ? '‚úÖ' : '‚ö†Ô∏è'} Health check executado\n`;
        successMsg += '‚úÖ Sistema operacional\n\n';
        successMsg += 'üéâ **Servidor 161.35.176.216 atualizado!**\n\n';
        successMsg += 'üì± **Pr√≥ximos passos:**\n';
        successMsg += '‚Ä¢ Teste os comandos do bot\n';
        successMsg += '‚Ä¢ Use `!deploy status` para monitorar\n';
        successMsg += '‚Ä¢ Use `!deploy logs` se houver problemas';
        
        await message.reply(successMsg);
      } else {
        let warningMsg = '‚ö†Ô∏è **DEPLOY COM PROBLEMAS**\n\n';
        warningMsg += 'üìã **Sa√≠da do processo:**\n';
        warningMsg += `\`\`\`${output.substring(0, 800)}\`\`\`\n\n`;
        warningMsg += 'üí° **Recomenda√ß√µes:**\n';
        warningMsg += '1. Execute `!deploy status` para verificar\n';
        warningMsg += '2. Use `!deploy logs` para mais detalhes\n';
        warningMsg += '3. Tente `!deploy restart` se necess√°rio';
        
        await message.reply(warningMsg);
      }
      
      resolve();
    });
  });
}

// Fun√ß√£o para deploy local
async function deployLocal(message, client) {
  const logger = require('../../logger');
  
  await message.reply('üîÑ **REINICIANDO SISTEMA LOCAL**\\n\\n‚è≥ Processando...');
  
  return new Promise((resolve, reject) => {
    exec('npm run validate', { timeout: 60000 }, async (error, stdout, stderr) => {
      if (error) {
        await message.reply(`‚ùå **VALIDA√á√ÉO FALHOU**\\n\\n\`\`\`${error.message}\`\`\``);
        return reject(error);
      }
      
      // Reiniciar processo
      await message.reply('‚úÖ **VALIDA√á√ÉO OK**\\n\\nüîÑ Reiniciando sistema...');
      
      setTimeout(async () => {
        await message.reply('‚úÖ **SISTEMA REINICIADO**\\n\\nüéâ Bot funcionando normalmente!');
        resolve();
      }, 2000);
    });
  });
}

// Fun√ß√£o para deploy com Docker
async function deployDocker(message, client) {
  await message.reply('üê≥ **DEPLOY COM DOCKER**\\n\\n‚è≥ Construindo imagem...');
  
  return new Promise((resolve, reject) => {
    exec('npm run docker:build-local', { timeout: 300000 }, async (error, stdout, stderr) => {
      if (error) {
        await message.reply(`‚ùå **DOCKER BUILD FALHOU**\\n\\n\`\`\`${error.message}\`\`\``);
        return reject(error);
      }
      
      await message.reply('‚úÖ **DOCKER BUILD CONCLU√çDO**\\n\\nüéâ Imagem pronta para uso!');
      resolve();
    });
  });
}

// Fun√ß√£o para status do sistema
async function deployStatus(message, client) {
  return new Promise((resolve, reject) => {
    exec('pm2 status', { timeout: 10000 }, async (error, stdout, stderr) => {
      let statusMsg = 'üìä **STATUS DO SISTEMA**\\n\\n';
      
      if (error) {
        statusMsg += '‚ùå PM2 n√£o dispon√≠vel localmente\\n\\n';
      } else {
        statusMsg += `\`\`\`${stdout.substring(0, 500)}\`\`\`\\n\\n`;
      }
      
      // Verificar health endpoint
      exec('curl -s http://localhost:8080/health || echo "Health endpoint n√£o dispon√≠vel"', 
           { timeout: 5000 }, async (healthError, healthOut) => {
        statusMsg += `üåê **Health Check:**\\n\`\`\`${healthOut || 'N√£o dispon√≠vel'}\`\`\`\\n\\n`;
        
        // Verificar uptime
        const uptimeHours = Math.floor(process.uptime() / 3600);
        const uptimeMinutes = Math.floor((process.uptime() % 3600) / 60);
        statusMsg += `‚è∞ **Uptime:** ${uptimeHours}h ${uptimeMinutes}m`;
        
        await message.reply(statusMsg);
        resolve();
      });
    });
  });
}

// Fun√ß√£o para logs
async function deployLogs(message, client) {
  return new Promise((resolve, reject) => {
    exec('pm2 logs whatsapp-bot --lines 10 --nostream', { timeout: 10000 }, async (error, stdout, stderr) => {
      let logMsg = 'üìã **√öLTIMOS LOGS**\\n\\n';
      
      if (error) {
        logMsg += '‚ùå Logs PM2 n√£o dispon√≠veis\\n\\n';
        // Tentar logs locais
        exec('tail -10 logs/*.log', { timeout: 5000 }, async (logError, logOut) => {
          if (!logError && logOut) {
            logMsg += `\`\`\`${logOut.substring(0, 800)}\`\`\``;
          } else {
            logMsg += 'Nenhum log dispon√≠vel';
          }
          
          await message.reply(logMsg);
          resolve();
        });
      } else {
        logMsg += `\`\`\`${stdout.substring(0, 800)}\`\`\``;
        await message.reply(logMsg);
        resolve();
      }
    });
  });
}

// Fun√ß√£o para restart PM2
async function deployRestart(message, client) {
  await message.reply('üîÑ **REINICIANDO PM2**\\n\\n‚è≥ Processando...');
  
  return new Promise((resolve, reject) => {
    exec('pm2 restart whatsapp-bot', { timeout: 30000 }, async (error, stdout, stderr) => {
      if (error) {
        await message.reply(`‚ùå **RESTART FALHOU**\\n\\n\`\`\`${error.message}\`\`\``);
        return reject(error);
      }
      
      await message.reply('‚úÖ **PM2 REINICIADO**\\n\\nüéâ Sistema funcionando normalmente!');
      resolve();
    });
  });
}

